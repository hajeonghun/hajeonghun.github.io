---
title: CORS(Cross-Origin Resource Sharing) 이해하기 (2)
date: 2025-01-21 16:30:00 +09:00
last_modified_at: 2025-01-21 16:30:00 +09:00
categories: [Browser]
tags:
  [
    CORS,
    SOP,
    Browser
  ]
---

- [CORS(Cross-Origin Resource Sharing) 이해하기 (1)](https://hajeonghun.github.io/posts/CORS-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-(1)/)

## CORS(Cross-Origin Resource Sharing)
CORS(Cross-Origin Resource Sharing)는 브라우저가 다른 출처(Cross-Origin)로부터 리소스를 가져올 수 있도록 서버가 허가 해주는 HTTP 헤더 기반 메커니즘입니다.  
다시말해, SOP의 기본 보안 철학을 유지하면서 신뢰할 수 있는 출처에 한해 특정 리소스를 공유할 수 있도록 허용하는 정책입니다.

![Image](https://github.com/user-attachments/assets/db3e37df-079f-418f-a4f2-2df9fa8573ee)

### CORS를 사용하는 요청
#### 1. fetch, XMLHttpRequest
- `fetch()`와 `XMLHttpRequest`는 자바스크립트로 HTTP 요청을 보낼 때 사용하는 메서드입니다.
- SOP의 영향으로 기본적으로 다른 출처로 요청을 보내거나 응답 데이터를 읽는 것은 제한됩니다.
- 그러나 서버가 적절한 CORS 헤더(`Access-Control-Allow-Origin`)를 Response Header에 포함하면 다른 출처에서도 요청과 응답을 처리할 수 있습니다.

#### 2. 웹 폰트(Web Fonts)
- CSS의 `@font-face` 규칙을 사용하여 다른 출처(Cross-Origin)에서 폰트를 로드할 수 있습니다.
- 하지만 교차 출처(Cross-Origin)에서 폰트를 가져오려면 서버에서 CORS 헤더를 설정해야 합니다.
  - 예를 들어, `Access-Control-Allow-Origin` 헤더가 없으면 브라우저는 해당 폰트를 로드하지 않습니다.
- 이 방식은 특정 웹사이트에서만 사용할 수 있는 폰트를 보호하는 데 유용합니다.

#### 3. WebGL 텍스처(WebGL Textures)
- [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API){:target="_blank"}은 3D 그래픽을 렌더링하기 위한 브라우저 API입니다.
- WebGL에서 외부 이미지를 텍스처로 사용하려면 해당 이미지가 있는 서버에 CORS 헤더가 설정되어 있어야 합니다.
- CORS 설정이 없으면 WebGL은 이미지를 렌더링하지 못합니다.

#### 4. Canvas에서 그린 이미지/비디오 프레임
- HTML `<canvas>` 요소의 `drawImage()` 메서드를 사용해 이미지나 비디오를 캔버스에 그릴 때, 외부 리소스를 사용하려면 서버가 CORS 헤더를 설정해야 합니다.
- 만약 CORS 헤더가 없으면 캔버스에 이미지를 그리더라도 `toDataURL()` 같은 메서드를 사용할 때 **오류**가 발생하여 데이터를 추출할 수 없습니다.
  - 이는 보안상의 이유로, 외부 데이터를 악용하지 못하게 하기 위한 제한입니다.

#### 5. CSS Shapes
- [CSS Shapes](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_shapes){:target="_blank"}는 콘텐츠를 특정 형태로 감싸거나 Clipping(잘라내기)하는 데 사용됩니다.
- 외부 이미지를 사용하여 이러한 형태를 정의하려면 이미지가 로드되는 서버에 CORS 헤더가 필요합니다.
- CORS가 설정되지 않으면 외부 이미지를 CSS Shapes에 사용할 수 없습니다.

## CORS 동작 방식

### Simple Requests(단순 요청)
**Simple Request(단순 요청)** 은 CORS에서 Preflight Request(사전 요청) `OPTIONS`을 트리거하지 않는 요청을 의미합니다.  
이 요청은 특정 조건을 충족해야 하며, 서버가 CORS 관련 헤더(Access-Control-Allow-Origin)로 응답하면 브라우저가 이를 허용합니다.  

`Simple Requests`라는 용어는 과거 [CORS 스펙초기](https://www.w3.org/TR/2014/REC-cors-20140116/#simple-cross-origin-request-0){:target="_blank"}에는 사용했지만 현재 CORS를 정의하고 있는 [fetch 스펙](https://fetch.spec.whatwg.org/){:target="_blank"}에는 사용되고 있지 않습니다.  

> 💡 왜 "Simple Requests(단순 요청)"용어를 현재 공식적으로 사용하지 않을까요?
>    - 단순 요청이라는 표현은 사람들이 CORS의 동작 방식을 잘못 이해하게 만들 수 있었습니다.
>    - 예를 들어, "단순 요청은 CORS와 무관하다"라고 오해할 수 있는데, 사실은 여전히 CORS 정책의 영향을 받으며, 서버가 `Access-Control-Allow-Origin` 헤더를 설정하지 않으면 브라우저는 스크립트가 응답 데이터에 접근하지 못하게 합니다.


### Simple Request(단순 요청) 조건
Simple Request(단순 요청)는 일반적으로 다음 조건을 모두 충족해야 합니다.  
*(브라우저마다 추가 제한 사항이 다를 수 있습니다.)*  

#### 1. **허용된 HTTP 메서드**
단순 요청은 아래의 세 가지 메서드 중 하나여야 합니다
- **`GET`**
- **`HEAD`**
- **`POST`**

**예시 코드**
  
```javascript
fetch("https://hajeonghun.com/api/data", {
  method: "GET", // 허용된 메서드
});
```
만약 `PUT`, `DELETE` 등의 메서드를 사용한다면 Preflight Request(사전 요청)이 트리거됩니다.

#### 2. 허용된 요청 헤더
단순 요청에서는 아래와 같은 [CORS-safelisted request-header](https://fetch.spec.whatwg.org/#cors-safelisted-request-header){:target="_blank"}만 수동으로 설정할 수 있습니다:
- **`Accept`**
- **`Accept-Language`**
- **`Content-Language`**
- **`Content-Type`** (추가 조건 있음, 아래 참고)
- **`Range`** (단, 특정 형식의 값이어야 함, 예: `bytes=256-` 또는 `bytes=127-255`)

브라우저가 자동으로 추가하는 기본 헤더(`User-Agent`, `Connection` 등)는 허용 여부에 영향을 미치지 않습니다.

**예시 코드**

```javascript
fetch("https://hajeonghun.com/api/data", {
  method: "POST",
  headers: {
    "Accept-Language": "en-US", // 허용된 헤더
    "Content-Type": "application/x-www-form-urlencoded", // 허용된 Content-Type
  },
});
```
만약 `Authorization` 같은 사용자 정의 헤더를 추가하면 사전 요청이 필요합니다.  

#### 3. Content-Type 헤더의 추가 조건
단순 요청에서 `Content-Type` 헤더를 사용할 경우, 아래의 MIME 타입만 허용됩니다:
- **`application/x-www-form-urlencoded`**: 주로 HTML `<form>` 데이터 전송에 사용.
- **`multipart/form-data`**: 파일 업로드 시 사용.
- **`text/plain`**: 일반 텍스트 전송.

**예시 코드(허용된 Content-Type)**  
아래는 단순 요청으로 간주되는 경우 입니다.

```javascript
fetch("https://hajeonghun.com/api/data", {
  method: "POST",
  headers: {
    "Content-Type": "application/x-www-form-urlencoded", // 허용된 MIME 타입
  },
  body: "name=John&age=30",
});
```

**예시 코드(허용되지 않은 Content-Type)**  
`Content-Type: application/json` 같은 값은 단순 요청이 아니며, 사전 요청을 필요로 합니다.

```javascript
fetch("https://hajeonghun.com/api/data", {
  method: "POST",
  headers: {
    "Content-Type": "application/json", // 사전 요청 트리거
  },
});
```

#### 4. XMLHttpRequest.upload 객체의 이벤트 리스너
XMLHttpRequest 객체를 사용하여 요청을 보낼 때, xhr.upload 객체에 이벤트 리스너를 등록하지 않아야 합니다.  

**예시 코드(허용되는 경우)**

```javascript
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://hajeonghun.com/api/data", true);
xhr.send("name=Ha&age=30");
```
![Image](https://github.com/user-attachments/assets/e045de29-b7eb-438f-8837-89f9c2503599)  

**예시 코드(허용되지 않는 경우)**

```javascript
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://hajeonghun.com/api/data", true);

// `xhr.upload`에 이벤트 리스너를 추가하면 사전 요청이 트리거 됨
xhr.upload.addEventListener("progress", (e) => {
  console.log("progress: ", e.loaded);
});
xhr.send("name=Ha&age=30");
```
![Image](https://github.com/user-attachments/assets/2ce13cba-4c65-43e4-9de4-f2b9164daf99)  
